{"ast":null,"code":"// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const ROWS = 6;\nexport const COLS = 7;\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n/**\n * Create an empty game board\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard() {\n  return Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  for (let row = ROWS - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n\n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return {\n      board: newBoard,\n      rowIndex: null\n    };\n  }\n\n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return {\n    board: newBoard,\n    rowIndex\n  };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = {\n    row: -direction.row,\n    col: -direction.col\n  };\n\n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {\n    winningCells.push({\n      row: r,\n      col: c\n    });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n\n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {\n    winningCells.push({\n      row: r,\n      col: c\n    });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [{\n    row: 0,\n    col: 1\n  },\n  // horizontal\n  {\n    row: 1,\n    col: 0\n  },\n  // vertical\n  {\n    row: 1,\n    col: 1\n  },\n  // diagonal down-right\n  {\n    row: 1,\n    col: -1\n  } // diagonal down-left\n  ];\n  const player = board[rowIndex][colIndex];\n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  return {\n    win: false,\n    winningCells: []\n  };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return {\n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= COLS) {\n    return false;\n  }\n\n  // Check if column is not full\n  return findLowestEmptyRow(board, colIndex) !== -1;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  return Array(COLS).fill().map((_, i) => i).filter(colIndex => isValidMove(board, colIndex));\n}","map":{"version":3,"names":["ROWS","COLS","EMPTY","PLAYER_1","PLAYER_2","createEmptyBoard","Array","fill","map","findLowestEmptyRow","board","colIndex","row","isBoardFull","every","cell","makeMove","player","newBoard","rowIndex","checkDirection","col","direction","winningCells","oppositeDirection","count","r","c","push","win","checkWin","directions","result","getGameStatus","lastRow","lastCol","status","winner","winResult","isValidMove","getValidMoves","_","i","filter"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/gameLogic.js"],"sourcesContent":["// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const ROWS = 6;\nexport const COLS = 7;\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n/**\n * Create an empty game board\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard() {\n  return Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  for (let row = ROWS - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n  \n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return { board: newBoard, rowIndex: null };\n  }\n  \n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return { board: newBoard, rowIndex };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = { row: -direction.row, col: -direction.col };\n  \n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n  \n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  \n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [\n    { row: 0, col: 1 },  // horizontal\n    { row: 1, col: 0 },  // vertical\n    { row: 1, col: 1 },  // diagonal down-right\n    { row: 1, col: -1 }, // diagonal down-left\n  ];\n  \n  const player = board[rowIndex][colIndex];\n  \n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  \n  return { win: false, winningCells: [] };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return { \n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  \n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= COLS) {\n    return false;\n  }\n  \n  // Check if column is not full\n  return findLowestEmptyRow(board, colIndex) !== -1;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  return Array(COLS).fill()\n    .map((_, i) => i)\n    .filter(colIndex => isValidMove(board, colIndex));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}