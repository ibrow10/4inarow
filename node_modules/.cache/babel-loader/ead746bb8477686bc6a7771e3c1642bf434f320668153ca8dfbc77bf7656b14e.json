{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport{COLS,ROWS,EMPTY,PLAYER_1,PLAYER_2,getValidMoves,makeMove,checkWin,isValidMove}from'./gameLogic';/**\n * AI difficulty levels\n */export const AI_LEVEL={EASY:'easy',MEDIUM:'medium',HARD:'hard'};/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */export function getAIMove(board,aiPlayer){let difficulty=arguments.length>2&&arguments[2]!==undefined?arguments[2]:AI_LEVEL.MEDIUM;const humanPlayer=aiPlayer===PLAYER_1?PLAYER_2:PLAYER_1;switch(difficulty){case AI_LEVEL.EASY:return getRandomMove(board);case AI_LEVEL.MEDIUM:return getMediumMove(board,aiPlayer,humanPlayer);case AI_LEVEL.HARD:return getHardMove(board,aiPlayer,humanPlayer);default:return getMediumMove(board,aiPlayer,humanPlayer);}}/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */function getRandomMove(board){const validMoves=getValidMoves(board);if(validMoves.length===0){return-1;// No valid moves\n}const randomIndex=Math.floor(Math.random()*validMoves.length);return validMoves[randomIndex];}/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */function getMediumMove(board,aiPlayer,humanPlayer){// Check if AI can win in one move\nconst winningMove=findWinningMove(board,aiPlayer);if(winningMove!==-1){return winningMove;}// Block human player from winning in one move\nconst blockingMove=findWinningMove(board,humanPlayer);if(blockingMove!==-1){return blockingMove;}// Prefer center column\nconst centerColumn=3;if(isValidMove(board,centerColumn)){return centerColumn;}// Otherwise make a random move\nreturn getRandomMove(board);}/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */function getHardMove(board,aiPlayer,humanPlayer){// Check if AI can win in one move\nconst winningMove=findWinningMove(board,aiPlayer);if(winningMove!==-1){return winningMove;}// Block human player from winning in one move\nconst blockingMove=findWinningMove(board,humanPlayer);if(blockingMove!==-1){return blockingMove;}// Evaluate potential moves with minimax (limited depth)\nlet bestScore=-Infinity;let bestMove=-1;const validMoves=getValidMoves(board);for(const colIndex of validMoves){const{board:newBoard,rowIndex}=makeMove(board,colIndex,aiPlayer);// Skip invalid moves\nif(rowIndex===null)continue;// Evaluate this move\nconst score=minimax(newBoard,4,false,aiPlayer,humanPlayer,-Infinity,Infinity);if(score>bestScore){bestScore=score;bestMove=colIndex;}}// If no good move found, use center or random\nif(bestMove===-1){bestMove=isValidMove(board,3)?3:getRandomMove(board);}return bestMove;}/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */function findWinningMove(board,player){for(let col=0;col<COLS;col++){if(!isValidMove(board,col))continue;const{board:newBoard,rowIndex}=makeMove(board,col,player);if(rowIndex!==null){const winResult=checkWin(newBoard,rowIndex,col);if(winResult.win){return col;}}}return-1;// No winning move found\n}/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */function evaluateBoard(board,aiPlayer,humanPlayer){let score=0;// Evaluate horizontal windows\nfor(let row=0;row<ROWS;row++){for(let col=0;col<=COLS-4;col++){score+=evaluateWindow([board[row][col],board[row][col+1],board[row][col+2],board[row][col+3]],aiPlayer,humanPlayer);}}// Evaluate vertical windows\nfor(let col=0;col<COLS;col++){for(let row=0;row<=ROWS-4;row++){score+=evaluateWindow([board[row][col],board[row+1][col],board[row+2][col],board[row+3][col]],aiPlayer,humanPlayer);}}// Evaluate diagonal (down-right) windows\nfor(let row=0;row<=ROWS-4;row++){for(let col=0;col<=COLS-4;col++){score+=evaluateWindow([board[row][col],board[row+1][col+1],board[row+2][col+2],board[row+3][col+3]],aiPlayer,humanPlayer);}}// Evaluate diagonal (down-left) windows\nfor(let row=0;row<=ROWS-4;row++){for(let col=COLS-1;col>=3;col--){score+=evaluateWindow([board[row][col],board[row+1][col-1],board[row+2][col-2],board[row+3][col-3]],aiPlayer,humanPlayer);}}// Prefer center column\nconst centerCol=Math.floor(COLS/2);for(let row=0;row<ROWS;row++){if(board[row][centerCol]===aiPlayer){score+=3;}}return score;}/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */function evaluateWindow(window,aiPlayer,humanPlayer){const aiCount=window.filter(cell=>cell===aiPlayer).length;const humanCount=window.filter(cell=>cell===humanPlayer).length;const emptyCount=window.filter(cell=>cell===EMPTY).length;// AI win\nif(aiCount===4)return 100;// AI can win next move\nif(aiCount===3&&emptyCount===1)return 5;// AI has two in a row with spaces\nif(aiCount===2&&emptyCount===2)return 2;// Human win (very bad)\nif(humanCount===4)return-100;// Human can win next move (block urgently)\nif(humanCount===3&&emptyCount===1)return-10;// Human has two in a row with spaces\nif(humanCount===2&&emptyCount===2)return-2;return 0;}/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */function minimax(board,depth,isMaximizing,aiPlayer,humanPlayer,alpha,beta){// Terminal conditions\nconst validMoves=getValidMoves(board);// Game over or max depth reached\nif(depth===0||validMoves.length===0){return evaluateBoard(board,aiPlayer,humanPlayer);}// Check for immediate wins/losses\nfor(const col of validMoves){const player=isMaximizing?aiPlayer:humanPlayer;const{board:newBoard,rowIndex}=makeMove(board,col,player);if(rowIndex!==null){const winResult=checkWin(newBoard,rowIndex,col);if(winResult.win){return isMaximizing?1000:-1000;}}}if(isMaximizing){let maxEval=-Infinity;for(const col of validMoves){const{board:newBoard,rowIndex}=makeMove(board,col,aiPlayer);if(rowIndex===null)continue;const evalScore=minimax(newBoard,depth-1,false,aiPlayer,humanPlayer,alpha,beta);maxEval=Math.max(maxEval,evalScore);// Alpha-beta pruning\nalpha=Math.max(alpha,evalScore);if(beta<=alpha)break;}return maxEval;}else{let minEval=Infinity;for(const col of validMoves){const{board:newBoard,rowIndex}=makeMove(board,col,humanPlayer);if(rowIndex===null)continue;const evalScore=minimax(newBoard,depth-1,true,aiPlayer,humanPlayer,alpha,beta);minEval=Math.min(minEval,evalScore);// Alpha-beta pruning\nbeta=Math.min(beta,evalScore);if(beta<=alpha)break;}return minEval;}}","map":{"version":3,"names":["COLS","ROWS","EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","EASY","MEDIUM","HARD","getAIMove","board","aiPlayer","difficulty","arguments","length","undefined","humanPlayer","getRandomMove","getMediumMove","getHardMove","validMoves","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","centerColumn","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","player","col","winResult","win","evaluateBoard","row","evaluateWindow","centerCol","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","maxEval","evalScore","max","minEval","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  COLS,\n  ROWS,\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI difficulty levels\n */\nexport const AI_LEVEL = {\n  EASY: 'easy',\n  MEDIUM: 'medium',\n  HARD: 'hard'\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n  \n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = COLS - 1; col >= 3; col--) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // AI win\n  if (aiCount === 4) return 100;\n  \n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n  \n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n  \n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n  \n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n  \n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  const validMoves = getValidMoves(board);\n  \n  // Game over or max depth reached\n  if (depth === 0 || validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Check for immediate wins/losses\n  for (const col of validMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  \n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return minEval;\n  }\n}\n"],"mappings":"AAAA;AACA,OACEA,IAAI,CACJC,IAAI,CACJC,KAAK,CACLC,QAAQ,CACRC,QAAQ,CACRC,aAAa,CACbC,QAAQ,CACRC,QAAQ,CACRC,WAAW,KACN,aAAa,CAEpB;AACA;AACA,GACA,MAAO,MAAM,CAAAC,QAAQ,CAAG,CACtBC,IAAI,CAAE,MAAM,CACZC,MAAM,CAAE,QAAQ,CAChBC,IAAI,CAAE,MACR,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAC,SAASA,CAACC,KAAK,CAAEC,QAAQ,CAAgC,IAA9B,CAAAC,UAAU,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAGR,QAAQ,CAACE,MAAM,CACrE,KAAM,CAAAS,WAAW,CAAGL,QAAQ,GAAKZ,QAAQ,CAAGC,QAAQ,CAAGD,QAAQ,CAE/D,OAAQa,UAAU,EAChB,IAAK,CAAAP,QAAQ,CAACC,IAAI,CAChB,MAAO,CAAAW,aAAa,CAACP,KAAK,CAAC,CAC7B,IAAK,CAAAL,QAAQ,CAACE,MAAM,CAClB,MAAO,CAAAW,aAAa,CAACR,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAC,CACpD,IAAK,CAAAX,QAAQ,CAACG,IAAI,CAChB,MAAO,CAAAW,WAAW,CAACT,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAC,CAClD,QACE,MAAO,CAAAE,aAAa,CAACR,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAC,CACtD,CACF,CAEA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAC,aAAaA,CAACP,KAAK,CAAE,CAC5B,KAAM,CAAAU,UAAU,CAAGnB,aAAa,CAACS,KAAK,CAAC,CAEvC,GAAIU,UAAU,CAACN,MAAM,GAAK,CAAC,CAAE,CAC3B,MAAO,CAAC,CAAC,CAAE;AACb,CAEA,KAAM,CAAAO,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAGJ,UAAU,CAACN,MAAM,CAAC,CACjE,MAAO,CAAAM,UAAU,CAACC,WAAW,CAAC,CAChC,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAH,aAAaA,CAACR,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAE,CACnD;AACA,KAAM,CAAAS,WAAW,CAAGC,eAAe,CAAChB,KAAK,CAAEC,QAAQ,CAAC,CACpD,GAAIc,WAAW,GAAK,CAAC,CAAC,CAAE,CACtB,MAAO,CAAAA,WAAW,CACpB,CAEA;AACA,KAAM,CAAAE,YAAY,CAAGD,eAAe,CAAChB,KAAK,CAAEM,WAAW,CAAC,CACxD,GAAIW,YAAY,GAAK,CAAC,CAAC,CAAE,CACvB,MAAO,CAAAA,YAAY,CACrB,CAEA;AACA,KAAM,CAAAC,YAAY,CAAG,CAAC,CACtB,GAAIxB,WAAW,CAACM,KAAK,CAAEkB,YAAY,CAAC,CAAE,CACpC,MAAO,CAAAA,YAAY,CACrB,CAEA;AACA,MAAO,CAAAX,aAAa,CAACP,KAAK,CAAC,CAC7B,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAS,WAAWA,CAACT,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAE,CACjD;AACA,KAAM,CAAAS,WAAW,CAAGC,eAAe,CAAChB,KAAK,CAAEC,QAAQ,CAAC,CACpD,GAAIc,WAAW,GAAK,CAAC,CAAC,CAAE,CACtB,MAAO,CAAAA,WAAW,CACpB,CAEA;AACA,KAAM,CAAAE,YAAY,CAAGD,eAAe,CAAChB,KAAK,CAAEM,WAAW,CAAC,CACxD,GAAIW,YAAY,GAAK,CAAC,CAAC,CAAE,CACvB,MAAO,CAAAA,YAAY,CACrB,CAEA;AACA,GAAI,CAAAE,SAAS,CAAG,CAACC,QAAQ,CACzB,GAAI,CAAAC,QAAQ,CAAG,CAAC,CAAC,CACjB,KAAM,CAAAX,UAAU,CAAGnB,aAAa,CAACS,KAAK,CAAC,CAEvC,IAAK,KAAM,CAAAsB,QAAQ,GAAI,CAAAZ,UAAU,CAAE,CACjC,KAAM,CAAEV,KAAK,CAAEuB,QAAQ,CAAEC,QAAS,CAAC,CAAGhC,QAAQ,CAACQ,KAAK,CAAEsB,QAAQ,CAAErB,QAAQ,CAAC,CAEzE;AACA,GAAIuB,QAAQ,GAAK,IAAI,CAAE,SAEvB;AACA,KAAM,CAAAC,KAAK,CAAGC,OAAO,CAACH,QAAQ,CAAE,CAAC,CAAE,KAAK,CAAEtB,QAAQ,CAAEK,WAAW,CAAE,CAACc,QAAQ,CAAEA,QAAQ,CAAC,CAErF,GAAIK,KAAK,CAAGN,SAAS,CAAE,CACrBA,SAAS,CAAGM,KAAK,CACjBJ,QAAQ,CAAGC,QAAQ,CACrB,CACF,CAEA;AACA,GAAID,QAAQ,GAAK,CAAC,CAAC,CAAE,CACnBA,QAAQ,CAAG3B,WAAW,CAACM,KAAK,CAAE,CAAC,CAAC,CAAG,CAAC,CAAGO,aAAa,CAACP,KAAK,CAAC,CAC7D,CAEA,MAAO,CAAAqB,QAAQ,CACjB,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAL,eAAeA,CAAChB,KAAK,CAAE2B,MAAM,CAAE,CACtC,IAAK,GAAI,CAAAC,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAG1C,IAAI,CAAE0C,GAAG,EAAE,CAAE,CACnC,GAAI,CAAClC,WAAW,CAACM,KAAK,CAAE4B,GAAG,CAAC,CAAE,SAE9B,KAAM,CAAE5B,KAAK,CAAEuB,QAAQ,CAAEC,QAAS,CAAC,CAAGhC,QAAQ,CAACQ,KAAK,CAAE4B,GAAG,CAAED,MAAM,CAAC,CAElE,GAAIH,QAAQ,GAAK,IAAI,CAAE,CACrB,KAAM,CAAAK,SAAS,CAAGpC,QAAQ,CAAC8B,QAAQ,CAAEC,QAAQ,CAAEI,GAAG,CAAC,CACnD,GAAIC,SAAS,CAACC,GAAG,CAAE,CACjB,MAAO,CAAAF,GAAG,CACZ,CACF,CACF,CAEA,MAAO,CAAC,CAAC,CAAE;AACb,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAG,aAAaA,CAAC/B,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAE,CACnD,GAAI,CAAAmB,KAAK,CAAG,CAAC,CAEb;AACA,IAAK,GAAI,CAAAO,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAG7C,IAAI,CAAE6C,GAAG,EAAE,CAAE,CACnC,IAAK,GAAI,CAAAJ,GAAG,CAAG,CAAC,CAAEA,GAAG,EAAI1C,IAAI,CAAG,CAAC,CAAE0C,GAAG,EAAE,CAAE,CACxCH,KAAK,EAAIQ,cAAc,CACrB,CAACjC,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAC,CAC1E3B,QAAQ,CACRK,WACF,CAAC,CACH,CACF,CAEA;AACA,IAAK,GAAI,CAAAsB,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAG1C,IAAI,CAAE0C,GAAG,EAAE,CAAE,CACnC,IAAK,GAAI,CAAAI,GAAG,CAAG,CAAC,CAAEA,GAAG,EAAI7C,IAAI,CAAG,CAAC,CAAE6C,GAAG,EAAE,CAAE,CACxCP,KAAK,EAAIQ,cAAc,CACrB,CAACjC,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAC1E3B,QAAQ,CACRK,WACF,CAAC,CACH,CACF,CAEA;AACA,IAAK,GAAI,CAAA0B,GAAG,CAAG,CAAC,CAAEA,GAAG,EAAI7C,IAAI,CAAG,CAAC,CAAE6C,GAAG,EAAE,CAAE,CACxC,IAAK,GAAI,CAAAJ,GAAG,CAAG,CAAC,CAAEA,GAAG,EAAI1C,IAAI,CAAG,CAAC,CAAE0C,GAAG,EAAE,CAAE,CACxCH,KAAK,EAAIQ,cAAc,CACrB,CAACjC,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAC,CAChF3B,QAAQ,CACRK,WACF,CAAC,CACH,CACF,CAEA;AACA,IAAK,GAAI,CAAA0B,GAAG,CAAG,CAAC,CAAEA,GAAG,EAAI7C,IAAI,CAAG,CAAC,CAAE6C,GAAG,EAAE,CAAE,CACxC,IAAK,GAAI,CAAAJ,GAAG,CAAG1C,IAAI,CAAG,CAAC,CAAE0C,GAAG,EAAI,CAAC,CAAEA,GAAG,EAAE,CAAE,CACxCH,KAAK,EAAIQ,cAAc,CACrB,CAACjC,KAAK,CAACgC,GAAG,CAAC,CAACJ,GAAG,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAE5B,KAAK,CAACgC,GAAG,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAC,CAChF3B,QAAQ,CACRK,WACF,CAAC,CACH,CACF,CAEA;AACA,KAAM,CAAA4B,SAAS,CAAGtB,IAAI,CAACC,KAAK,CAAC3B,IAAI,CAAG,CAAC,CAAC,CACtC,IAAK,GAAI,CAAA8C,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAG7C,IAAI,CAAE6C,GAAG,EAAE,CAAE,CACnC,GAAIhC,KAAK,CAACgC,GAAG,CAAC,CAACE,SAAS,CAAC,GAAKjC,QAAQ,CAAE,CACtCwB,KAAK,EAAI,CAAC,CACZ,CACF,CAEA,MAAO,CAAAA,KAAK,CACd,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAQ,cAAcA,CAACE,MAAM,CAAElC,QAAQ,CAAEK,WAAW,CAAE,CACrD,KAAM,CAAA8B,OAAO,CAAGD,MAAM,CAACE,MAAM,CAACC,IAAI,EAAIA,IAAI,GAAKrC,QAAQ,CAAC,CAACG,MAAM,CAC/D,KAAM,CAAAmC,UAAU,CAAGJ,MAAM,CAACE,MAAM,CAACC,IAAI,EAAIA,IAAI,GAAKhC,WAAW,CAAC,CAACF,MAAM,CACrE,KAAM,CAAAoC,UAAU,CAAGL,MAAM,CAACE,MAAM,CAACC,IAAI,EAAIA,IAAI,GAAKlD,KAAK,CAAC,CAACgB,MAAM,CAE/D;AACA,GAAIgC,OAAO,GAAK,CAAC,CAAE,MAAO,IAAG,CAE7B;AACA,GAAIA,OAAO,GAAK,CAAC,EAAII,UAAU,GAAK,CAAC,CAAE,MAAO,EAAC,CAE/C;AACA,GAAIJ,OAAO,GAAK,CAAC,EAAII,UAAU,GAAK,CAAC,CAAE,MAAO,EAAC,CAE/C;AACA,GAAID,UAAU,GAAK,CAAC,CAAE,MAAO,CAAC,GAAG,CAEjC;AACA,GAAIA,UAAU,GAAK,CAAC,EAAIC,UAAU,GAAK,CAAC,CAAE,MAAO,CAAC,EAAE,CAEpD;AACA,GAAID,UAAU,GAAK,CAAC,EAAIC,UAAU,GAAK,CAAC,CAAE,MAAO,CAAC,CAAC,CAEnD,MAAO,EAAC,CACV,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAd,OAAOA,CAAC1B,KAAK,CAAEyC,KAAK,CAAEC,YAAY,CAAEzC,QAAQ,CAAEK,WAAW,CAAEqC,KAAK,CAAEC,IAAI,CAAE,CAC/E;AACA,KAAM,CAAAlC,UAAU,CAAGnB,aAAa,CAACS,KAAK,CAAC,CAEvC;AACA,GAAIyC,KAAK,GAAK,CAAC,EAAI/B,UAAU,CAACN,MAAM,GAAK,CAAC,CAAE,CAC1C,MAAO,CAAA2B,aAAa,CAAC/B,KAAK,CAAEC,QAAQ,CAAEK,WAAW,CAAC,CACpD,CAEA;AACA,IAAK,KAAM,CAAAsB,GAAG,GAAI,CAAAlB,UAAU,CAAE,CAC5B,KAAM,CAAAiB,MAAM,CAAGe,YAAY,CAAGzC,QAAQ,CAAGK,WAAW,CACpD,KAAM,CAAEN,KAAK,CAAEuB,QAAQ,CAAEC,QAAS,CAAC,CAAGhC,QAAQ,CAACQ,KAAK,CAAE4B,GAAG,CAAED,MAAM,CAAC,CAElE,GAAIH,QAAQ,GAAK,IAAI,CAAE,CACrB,KAAM,CAAAK,SAAS,CAAGpC,QAAQ,CAAC8B,QAAQ,CAAEC,QAAQ,CAAEI,GAAG,CAAC,CACnD,GAAIC,SAAS,CAACC,GAAG,CAAE,CACjB,MAAO,CAAAY,YAAY,CAAG,IAAI,CAAG,CAAC,IAAI,CACpC,CACF,CACF,CAEA,GAAIA,YAAY,CAAE,CAChB,GAAI,CAAAG,OAAO,CAAG,CAACzB,QAAQ,CAEvB,IAAK,KAAM,CAAAQ,GAAG,GAAI,CAAAlB,UAAU,CAAE,CAC5B,KAAM,CAAEV,KAAK,CAAEuB,QAAQ,CAAEC,QAAS,CAAC,CAAGhC,QAAQ,CAACQ,KAAK,CAAE4B,GAAG,CAAE3B,QAAQ,CAAC,CAEpE,GAAIuB,QAAQ,GAAK,IAAI,CAAE,SAEvB,KAAM,CAAAsB,SAAS,CAAGpB,OAAO,CAACH,QAAQ,CAAEkB,KAAK,CAAG,CAAC,CAAE,KAAK,CAAExC,QAAQ,CAAEK,WAAW,CAAEqC,KAAK,CAAEC,IAAI,CAAC,CACzFC,OAAO,CAAGjC,IAAI,CAACmC,GAAG,CAACF,OAAO,CAAEC,SAAS,CAAC,CAEtC;AACAH,KAAK,CAAG/B,IAAI,CAACmC,GAAG,CAACJ,KAAK,CAAEG,SAAS,CAAC,CAClC,GAAIF,IAAI,EAAID,KAAK,CAAE,MACrB,CAEA,MAAO,CAAAE,OAAO,CAChB,CAAC,IAAM,CACL,GAAI,CAAAG,OAAO,CAAG5B,QAAQ,CAEtB,IAAK,KAAM,CAAAQ,GAAG,GAAI,CAAAlB,UAAU,CAAE,CAC5B,KAAM,CAAEV,KAAK,CAAEuB,QAAQ,CAAEC,QAAS,CAAC,CAAGhC,QAAQ,CAACQ,KAAK,CAAE4B,GAAG,CAAEtB,WAAW,CAAC,CAEvE,GAAIkB,QAAQ,GAAK,IAAI,CAAE,SAEvB,KAAM,CAAAsB,SAAS,CAAGpB,OAAO,CAACH,QAAQ,CAAEkB,KAAK,CAAG,CAAC,CAAE,IAAI,CAAExC,QAAQ,CAAEK,WAAW,CAAEqC,KAAK,CAAEC,IAAI,CAAC,CACxFI,OAAO,CAAGpC,IAAI,CAACqC,GAAG,CAACD,OAAO,CAAEF,SAAS,CAAC,CAEtC;AACAF,IAAI,CAAGhC,IAAI,CAACqC,GAAG,CAACL,IAAI,CAAEE,SAAS,CAAC,CAChC,GAAIF,IAAI,EAAID,KAAK,CAAE,MACrB,CAEA,MAAO,CAAAK,OAAO,CAChB,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}