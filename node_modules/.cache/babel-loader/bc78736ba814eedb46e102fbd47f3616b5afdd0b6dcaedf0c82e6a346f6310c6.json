{"ast":null,"code":"// gameLogic.js - Core Connect 4 logic\n// Constants\nexport const EMPTY=null;export const PLAYER_1=1;export const PLAYER_2=2;// Grid size options\nexport const GRID_SIZES={STANDARD:'standard',MEDIUM:'medium',LARGE:'large'};// Grid dimensions for each size\nexport const GRID_DIMENSIONS={[GRID_SIZES.STANDARD]:{rows:6,cols:7},[GRID_SIZES.MEDIUM]:{rows:11,cols:11},[GRID_SIZES.LARGE]:{rows:21,cols:21}};// Default grid size\nexport const DEFAULT_GRID_SIZE=GRID_SIZES.STANDARD;// Helper functions to get current dimensions\nexport function getRows(){let gridSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_GRID_SIZE;return GRID_DIMENSIONS[gridSize].rows;}export function getCols(){let gridSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_GRID_SIZE;return GRID_DIMENSIONS[gridSize].cols;}/**\n * Create an empty game board\n * @param {string} gridSize - Size of the grid\n * @returns {Array<Array<null>>} Empty board\n */export function createEmptyBoard(){let gridSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_GRID_SIZE;const rows=getRows(gridSize);const cols=getCols(gridSize);return Array(rows).fill().map(()=>Array(cols).fill(EMPTY));}/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */export function findLowestEmptyRow(board,colIndex){const rows=board.length;for(let row=rows-1;row>=0;row--){if(board[row][colIndex]===EMPTY){return row;}}return-1;// Column is full\n}/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */export function isBoardFull(board){return board[0].every(cell=>cell!==EMPTY);}/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */export function makeMove(board,colIndex,player){// Create a copy of the board\nconst newBoard=board.map(row=>[...row]);const rowIndex=findLowestEmptyRow(board,colIndex);// Invalid move (column is full)\nif(rowIndex===-1){return{board:newBoard,rowIndex:null};}// Make the move\nnewBoard[rowIndex][colIndex]=player;return{board:newBoard,rowIndex};}/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */export function checkDirection(board,row,col,direction,player){const winningCells=[];const oppositeDirection={row:-direction.row,col:-direction.col};// Check in the positive direction\nlet count=0;let r=row;let c=col;while(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===player){winningCells.push({row:r,col:c});count++;r+=direction.row;c+=direction.col;}// Check in the negative direction\nr=row+oppositeDirection.row;c=col+oppositeDirection.col;while(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===player){winningCells.push({row:r,col:c});count++;r+=oppositeDirection.row;c+=oppositeDirection.col;}return{win:count>=4,winningCells:count>=4?winningCells:[]};}/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */export function checkWin(board,rowIndex,colIndex){const directions=[{row:0,col:1},// horizontal\n{row:1,col:0},// vertical\n{row:1,col:1},// diagonal down-right\n{row:1,col:-1}// diagonal down-left\n];const player=board[rowIndex][colIndex];for(const direction of directions){const result=checkDirection(board,rowIndex,colIndex,direction,player);if(result.win)return result;}return{win:false,winningCells:[]};}/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */export function getGameStatus(board,lastRow,lastCol){if(lastRow===null||lastCol===null){return{status:'inProgress',winner:null,winningCells:[]};}const winResult=checkWin(board,lastRow,lastCol);if(winResult.win){return{status:'win',winner:board[lastRow][lastCol],winningCells:winResult.winningCells};}if(isBoardFull(board)){return{status:'draw',winner:null,winningCells:[]};}return{status:'inProgress',winner:null,winningCells:[]};}/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */export function isValidMove(board,colIndex){const cols=board[0].length;// Check if column is within bounds\nif(colIndex<0||colIndex>=cols){return false;}// Check if the top cell in the column is empty\nreturn board[0][colIndex]===EMPTY;}/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */export function getValidMoves(board){const validMoves=[];const cols=board[0].length;for(let col=0;col<cols;col++){if(isValidMove(board,col)){validMoves.push(col);}}return validMoves;}","map":{"version":3,"names":["EMPTY","PLAYER_1","PLAYER_2","GRID_SIZES","STANDARD","MEDIUM","LARGE","GRID_DIMENSIONS","rows","cols","DEFAULT_GRID_SIZE","getRows","gridSize","arguments","length","undefined","getCols","createEmptyBoard","Array","fill","map","findLowestEmptyRow","board","colIndex","row","isBoardFull","every","cell","makeMove","player","newBoard","rowIndex","checkDirection","col","direction","winningCells","oppositeDirection","count","r","c","ROWS","COLS","push","win","checkWin","directions","result","getGameStatus","lastRow","lastCol","status","winner","winResult","isValidMove","getValidMoves","validMoves"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/gameLogic.js"],"sourcesContent":["// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n// Grid size options\nexport const GRID_SIZES = {\n  STANDARD: 'standard',\n  MEDIUM: 'medium',\n  LARGE: 'large'\n};\n\n// Grid dimensions for each size\nexport const GRID_DIMENSIONS = {\n  [GRID_SIZES.STANDARD]: { rows: 6, cols: 7 },\n  [GRID_SIZES.MEDIUM]: { rows: 11, cols: 11 },\n  [GRID_SIZES.LARGE]: { rows: 21, cols: 21 }\n};\n\n// Default grid size\nexport const DEFAULT_GRID_SIZE = GRID_SIZES.STANDARD;\n\n// Helper functions to get current dimensions\nexport function getRows(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].rows;\n}\n\nexport function getCols(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].cols;\n}\n\n/**\n * Create an empty game board\n * @param {string} gridSize - Size of the grid\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard(gridSize = DEFAULT_GRID_SIZE) {\n  const rows = getRows(gridSize);\n  const cols = getCols(gridSize);\n  return Array(rows).fill().map(() => Array(cols).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  const rows = board.length;\n  for (let row = rows - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n  \n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return { board: newBoard, rowIndex: null };\n  }\n  \n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return { board: newBoard, rowIndex };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = { row: -direction.row, col: -direction.col };\n  \n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n  \n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  \n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [\n    { row: 0, col: 1 },  // horizontal\n    { row: 1, col: 0 },  // vertical\n    { row: 1, col: 1 },  // diagonal down-right\n    { row: 1, col: -1 }, // diagonal down-left\n  ];\n  \n  const player = board[rowIndex][colIndex];\n  \n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  \n  return { win: false, winningCells: [] };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return { \n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  \n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  const cols = board[0].length;\n  \n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= cols) {\n    return false;\n  }\n  \n  // Check if the top cell in the column is empty\n  return board[0][colIndex] === EMPTY;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  const validMoves = [];\n  const cols = board[0].length;\n  \n  for (let col = 0; col < cols; col++) {\n    if (isValidMove(board, col)) {\n      validMoves.push(col);\n    }\n  }\n  \n  return validMoves;\n}\n"],"mappings":"AAAA;AAEA;AACA,MAAO,MAAM,CAAAA,KAAK,CAAG,IAAI,CACzB,MAAO,MAAM,CAAAC,QAAQ,CAAG,CAAC,CACzB,MAAO,MAAM,CAAAC,QAAQ,CAAG,CAAC,CAEzB;AACA,MAAO,MAAM,CAAAC,UAAU,CAAG,CACxBC,QAAQ,CAAE,UAAU,CACpBC,MAAM,CAAE,QAAQ,CAChBC,KAAK,CAAE,OACT,CAAC,CAED;AACA,MAAO,MAAM,CAAAC,eAAe,CAAG,CAC7B,CAACJ,UAAU,CAACC,QAAQ,EAAG,CAAEI,IAAI,CAAE,CAAC,CAAEC,IAAI,CAAE,CAAE,CAAC,CAC3C,CAACN,UAAU,CAACE,MAAM,EAAG,CAAEG,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,EAAG,CAAC,CAC3C,CAACN,UAAU,CAACG,KAAK,EAAG,CAAEE,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,EAAG,CAC3C,CAAC,CAED;AACA,MAAO,MAAM,CAAAC,iBAAiB,CAAGP,UAAU,CAACC,QAAQ,CAEpD;AACA,MAAO,SAAS,CAAAO,OAAOA,CAAA,CAA+B,IAA9B,CAAAC,QAAQ,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAGH,iBAAiB,CAClD,MAAO,CAAAH,eAAe,CAACK,QAAQ,CAAC,CAACJ,IAAI,CACvC,CAEA,MAAO,SAAS,CAAAQ,OAAOA,CAAA,CAA+B,IAA9B,CAAAJ,QAAQ,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAGH,iBAAiB,CAClD,MAAO,CAAAH,eAAe,CAACK,QAAQ,CAAC,CAACH,IAAI,CACvC,CAEA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAQ,gBAAgBA,CAAA,CAA+B,IAA9B,CAAAL,QAAQ,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAGH,iBAAiB,CAC3D,KAAM,CAAAF,IAAI,CAAGG,OAAO,CAACC,QAAQ,CAAC,CAC9B,KAAM,CAAAH,IAAI,CAAGO,OAAO,CAACJ,QAAQ,CAAC,CAC9B,MAAO,CAAAM,KAAK,CAACV,IAAI,CAAC,CAACW,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,IAAMF,KAAK,CAACT,IAAI,CAAC,CAACU,IAAI,CAACnB,KAAK,CAAC,CAAC,CAC9D,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAqB,kBAAkBA,CAACC,KAAK,CAAEC,QAAQ,CAAE,CAClD,KAAM,CAAAf,IAAI,CAAGc,KAAK,CAACR,MAAM,CACzB,IAAK,GAAI,CAAAU,GAAG,CAAGhB,IAAI,CAAG,CAAC,CAAEgB,GAAG,EAAI,CAAC,CAAEA,GAAG,EAAE,CAAE,CACxC,GAAIF,KAAK,CAACE,GAAG,CAAC,CAACD,QAAQ,CAAC,GAAKvB,KAAK,CAAE,CAClC,MAAO,CAAAwB,GAAG,CACZ,CACF,CACA,MAAO,CAAC,CAAC,CAAE;AACb,CAEA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAC,WAAWA,CAACH,KAAK,CAAE,CACjC,MAAO,CAAAA,KAAK,CAAC,CAAC,CAAC,CAACI,KAAK,CAACC,IAAI,EAAIA,IAAI,GAAK3B,KAAK,CAAC,CAC/C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAA4B,QAAQA,CAACN,KAAK,CAAEC,QAAQ,CAAEM,MAAM,CAAE,CAChD;AACA,KAAM,CAAAC,QAAQ,CAAGR,KAAK,CAACF,GAAG,CAACI,GAAG,EAAI,CAAC,GAAGA,GAAG,CAAC,CAAC,CAC3C,KAAM,CAAAO,QAAQ,CAAGV,kBAAkB,CAACC,KAAK,CAAEC,QAAQ,CAAC,CAEpD;AACA,GAAIQ,QAAQ,GAAK,CAAC,CAAC,CAAE,CACnB,MAAO,CAAET,KAAK,CAAEQ,QAAQ,CAAEC,QAAQ,CAAE,IAAK,CAAC,CAC5C,CAEA;AACAD,QAAQ,CAACC,QAAQ,CAAC,CAACR,QAAQ,CAAC,CAAGM,MAAM,CACrC,MAAO,CAAEP,KAAK,CAAEQ,QAAQ,CAAEC,QAAS,CAAC,CACtC,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAC,cAAcA,CAACV,KAAK,CAAEE,GAAG,CAAES,GAAG,CAAEC,SAAS,CAAEL,MAAM,CAAE,CACjE,KAAM,CAAAM,YAAY,CAAG,EAAE,CACvB,KAAM,CAAAC,iBAAiB,CAAG,CAAEZ,GAAG,CAAE,CAACU,SAAS,CAACV,GAAG,CAAES,GAAG,CAAE,CAACC,SAAS,CAACD,GAAI,CAAC,CAEtE;AACA,GAAI,CAAAI,KAAK,CAAG,CAAC,CACb,GAAI,CAAAC,CAAC,CAAGd,GAAG,CACX,GAAI,CAAAe,CAAC,CAAGN,GAAG,CAEX,MACEK,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGE,IAAI,EAClBD,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGE,IAAI,EAClBnB,KAAK,CAACgB,CAAC,CAAC,CAACC,CAAC,CAAC,GAAKV,MAAM,CACtB,CACAM,YAAY,CAACO,IAAI,CAAC,CAAElB,GAAG,CAAEc,CAAC,CAAEL,GAAG,CAAEM,CAAE,CAAC,CAAC,CACrCF,KAAK,EAAE,CACPC,CAAC,EAAIJ,SAAS,CAACV,GAAG,CAClBe,CAAC,EAAIL,SAAS,CAACD,GAAG,CACpB,CAEA;AACAK,CAAC,CAAGd,GAAG,CAAGY,iBAAiB,CAACZ,GAAG,CAC/Be,CAAC,CAAGN,GAAG,CAAGG,iBAAiB,CAACH,GAAG,CAE/B,MACEK,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGE,IAAI,EAClBD,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAGE,IAAI,EAClBnB,KAAK,CAACgB,CAAC,CAAC,CAACC,CAAC,CAAC,GAAKV,MAAM,CACtB,CACAM,YAAY,CAACO,IAAI,CAAC,CAAElB,GAAG,CAAEc,CAAC,CAAEL,GAAG,CAAEM,CAAE,CAAC,CAAC,CACrCF,KAAK,EAAE,CACPC,CAAC,EAAIF,iBAAiB,CAACZ,GAAG,CAC1Be,CAAC,EAAIH,iBAAiB,CAACH,GAAG,CAC5B,CAEA,MAAO,CACLU,GAAG,CAAEN,KAAK,EAAI,CAAC,CACfF,YAAY,CAAEE,KAAK,EAAI,CAAC,CAAGF,YAAY,CAAG,EAC5C,CAAC,CACH,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAS,QAAQA,CAACtB,KAAK,CAAES,QAAQ,CAAER,QAAQ,CAAE,CAClD,KAAM,CAAAsB,UAAU,CAAG,CACjB,CAAErB,GAAG,CAAE,CAAC,CAAES,GAAG,CAAE,CAAE,CAAC,CAAG;AACrB,CAAET,GAAG,CAAE,CAAC,CAAES,GAAG,CAAE,CAAE,CAAC,CAAG;AACrB,CAAET,GAAG,CAAE,CAAC,CAAES,GAAG,CAAE,CAAE,CAAC,CAAG;AACrB,CAAET,GAAG,CAAE,CAAC,CAAES,GAAG,CAAE,CAAC,CAAE,CAAG;AAAA,CACtB,CAED,KAAM,CAAAJ,MAAM,CAAGP,KAAK,CAACS,QAAQ,CAAC,CAACR,QAAQ,CAAC,CAExC,IAAK,KAAM,CAAAW,SAAS,GAAI,CAAAW,UAAU,CAAE,CAClC,KAAM,CAAAC,MAAM,CAAGd,cAAc,CAACV,KAAK,CAAES,QAAQ,CAAER,QAAQ,CAAEW,SAAS,CAAEL,MAAM,CAAC,CAC3E,GAAIiB,MAAM,CAACH,GAAG,CAAE,MAAO,CAAAG,MAAM,CAC/B,CAEA,MAAO,CAAEH,GAAG,CAAE,KAAK,CAAER,YAAY,CAAE,EAAG,CAAC,CACzC,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAY,aAAaA,CAACzB,KAAK,CAAE0B,OAAO,CAAEC,OAAO,CAAE,CACrD,GAAID,OAAO,GAAK,IAAI,EAAIC,OAAO,GAAK,IAAI,CAAE,CACxC,MAAO,CACLC,MAAM,CAAE,YAAY,CACpBC,MAAM,CAAE,IAAI,CACZhB,YAAY,CAAE,EAChB,CAAC,CACH,CAEA,KAAM,CAAAiB,SAAS,CAAGR,QAAQ,CAACtB,KAAK,CAAE0B,OAAO,CAAEC,OAAO,CAAC,CACnD,GAAIG,SAAS,CAACT,GAAG,CAAE,CACjB,MAAO,CACLO,MAAM,CAAE,KAAK,CACbC,MAAM,CAAE7B,KAAK,CAAC0B,OAAO,CAAC,CAACC,OAAO,CAAC,CAC/Bd,YAAY,CAAEiB,SAAS,CAACjB,YAC1B,CAAC,CACH,CAEA,GAAIV,WAAW,CAACH,KAAK,CAAC,CAAE,CACtB,MAAO,CACL4B,MAAM,CAAE,MAAM,CACdC,MAAM,CAAE,IAAI,CACZhB,YAAY,CAAE,EAChB,CAAC,CACH,CAEA,MAAO,CACLe,MAAM,CAAE,YAAY,CACpBC,MAAM,CAAE,IAAI,CACZhB,YAAY,CAAE,EAChB,CAAC,CACH,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAkB,WAAWA,CAAC/B,KAAK,CAAEC,QAAQ,CAAE,CAC3C,KAAM,CAAAd,IAAI,CAAGa,KAAK,CAAC,CAAC,CAAC,CAACR,MAAM,CAE5B;AACA,GAAIS,QAAQ,CAAG,CAAC,EAAIA,QAAQ,EAAId,IAAI,CAAE,CACpC,MAAO,MAAK,CACd,CAEA;AACA,MAAO,CAAAa,KAAK,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,GAAKvB,KAAK,CACrC,CAEA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAsD,aAAaA,CAAChC,KAAK,CAAE,CACnC,KAAM,CAAAiC,UAAU,CAAG,EAAE,CACrB,KAAM,CAAA9C,IAAI,CAAGa,KAAK,CAAC,CAAC,CAAC,CAACR,MAAM,CAE5B,IAAK,GAAI,CAAAmB,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAGxB,IAAI,CAAEwB,GAAG,EAAE,CAAE,CACnC,GAAIoB,WAAW,CAAC/B,KAAK,CAAEW,GAAG,CAAC,CAAE,CAC3BsB,UAAU,CAACb,IAAI,CAACT,GAAG,CAAC,CACtB,CACF,CAEA,MAAO,CAAAsB,UAAU,CACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}