{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport { EMPTY, PLAYER_1, PLAYER_2, getValidMoves, makeMove, checkWin, isValidMove } from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',\n  // Jim - Easy difficulty\n  ROSIE: 'medium',\n  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard' // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  switch (difficulty) {\n    case AI_LEVEL.JIM:\n      return getRandomMove(board);\n    case AI_LEVEL.ROSIE:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.DANGERMOUSE:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Uses minimax with moderate depth (same as old hard level)\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  for (const colIndex of validMoves) {\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, colIndex, aiPlayer);\n\n    // Skip invalid moves\n    if (rowIndex === null) continue;\n\n    // Evaluate this move (depth 4, same as old hard level)\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n\n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    const centerCol = Math.floor(board[0].length / 2);\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  return bestMove;\n}\n\n/**\n * Hard difficulty AI: Unbeatable AI using deep minimax search and advanced evaluation\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Count number of pieces to adjust search depth\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  let piecesCount = 0;\n  let totalCells = ROWS * COLS;\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      if (board[row][col] !== EMPTY) {\n        piecesCount++;\n      }\n    }\n  }\n\n  // Adjust search depth based on game progress and board size\n  // Deeper search at beginning and end, shallower in middle for performance\n  let searchDepth = 6; // Default depth\n\n  // For larger boards, reduce search depth to maintain performance\n  if (totalCells > 100) {\n    // Medium board (11x11 or larger)\n    searchDepth = 5;\n  } else if (totalCells > 300) {\n    // Large board (21x21 or larger)\n    searchDepth = 4;\n  }\n\n  // Adjust based on game progress\n  const gameProgressPercentage = piecesCount / totalCells * 100;\n  if (gameProgressPercentage < 15) {\n    searchDepth += 2; // Deep search at beginning\n  } else if (gameProgressPercentage > 70) {\n    searchDepth += 3; // Very deep search near end\n  }\n\n  // Evaluate potential moves with deeper minimax\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n\n  // Prioritize center columns for initial evaluation\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  for (const colIndex of orderedMoves) {\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, colIndex, aiPlayer);\n\n    // Skip invalid moves\n    if (rowIndex === null) continue;\n\n    // Check for immediate win\n    const winResult = checkWin(newBoard, rowIndex, colIndex);\n    if (winResult.win) {\n      return colIndex; // Immediate win found\n    }\n\n    // Evaluate this move with deeper search\n    const score = minimax(newBoard, searchDepth, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n\n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  const COLS = board[0].length;\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  const ROWS = board.length;\n  const COLS = board[0].length;\n\n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row][col + 1], board[row][col + 2], board[row][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col], board[row + 2][col], board[row + 3][col]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col + 1], board[row + 2][col + 2], board[row + 3][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 3; col < COLS; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col - 1], board[row + 2][col - 2], board[row + 3][col - 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Prefer center column(s)\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n    // For even-width boards, also prefer the column to the left of center\n    if (COLS % 2 === 0 && centerCol > 0) {\n      if (board[row][centerCol - 1] === aiPlayer) {\n        score += 2;\n      }\n    }\n  }\n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n\n  // Scoring based on pieces in window - enhanced for unbeatable AI\n  if (aiCount === 4) return 1000; // AI win - higher value\n  if (humanCount === 4) return -1000; // Human win - higher penalty\n\n  if (aiCount === 3 && emptyCount === 1) return 50; // AI potential win - much higher priority\n  if (humanCount === 3 && emptyCount === 1) return -50; // Block human potential win - much higher priority\n\n  if (aiCount === 2 && emptyCount === 2) return 10; // AI building up - higher value\n  if (humanCount === 2 && emptyCount === 2) return -10; // Human building up - higher penalty\n\n  // New patterns\n  if (aiCount === 1 && emptyCount === 3) return 1; // Starting to build\n  if (humanCount === 1 && emptyCount === 3) return -1; // Human starting to build\n\n  // Prefer empty windows slightly\n  if (emptyCount === 4) return 0.5;\n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  if (depth === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n\n  // Prioritize center columns for evaluation\n  const COLS = board[0].length;\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  if (isMaximizing) {\n    // AI's turn (maximizing)\n    let maxScore = -Infinity;\n    for (const colIndex of orderedMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, colIndex, aiPlayer);\n      if (rowIndex === null) continue;\n\n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return 1000 * depth; // Winning sooner is better\n      }\n      const score = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxScore = Math.max(maxScore, score);\n\n      // Alpha-beta pruning\n      alpha = Math.max(alpha, score);\n      if (beta <= alpha) break;\n    }\n    return maxScore;\n  } else {\n    // Human's turn (minimizing)\n    let minScore = Infinity;\n    for (const colIndex of orderedMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, colIndex, humanPlayer);\n      if (rowIndex === null) continue;\n\n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return -1000 * depth; // Losing sooner is worse\n      }\n      const score = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minScore = Math.min(minScore, score);\n\n      // Alpha-beta pruning\n      beta = Math.min(beta, score);\n      if (beta <= alpha) break;\n    }\n    return minScore;\n  }\n}","map":{"version":3,"names":["EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","JIM","ROSIE","DANGERMOUSE","AI_PERSONA","name","description","avatar","getAIMove","board","aiPlayer","difficulty","MEDIUM","humanPlayer","getRandomMove","getMediumMove","getHardMove","validMoves","length","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","centerCol","ROWS","COLS","piecesCount","totalCells","row","col","searchDepth","gameProgressPercentage","orderedMoves","sort","a","b","abs","winResult","win","player","evaluateBoard","evaluateWindow","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","maxScore","max","minScore","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',     // Jim - Easy difficulty\n  ROSIE: 'medium',  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard'  // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.JIM:\n      return getRandomMove(board);\n    case AI_LEVEL.ROSIE:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.DANGERMOUSE:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Uses minimax with moderate depth (same as old hard level)\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move (depth 4, same as old hard level)\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    const centerCol = Math.floor(board[0].length / 2);\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Hard difficulty AI: Unbeatable AI using deep minimax search and advanced evaluation\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Count number of pieces to adjust search depth\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  let piecesCount = 0;\n  let totalCells = ROWS * COLS;\n  \n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      if (board[row][col] !== EMPTY) {\n        piecesCount++;\n      }\n    }\n  }\n  \n  // Adjust search depth based on game progress and board size\n  // Deeper search at beginning and end, shallower in middle for performance\n  let searchDepth = 6; // Default depth\n  \n  // For larger boards, reduce search depth to maintain performance\n  if (totalCells > 100) { // Medium board (11x11 or larger)\n    searchDepth = 5;\n  } else if (totalCells > 300) { // Large board (21x21 or larger)\n    searchDepth = 4;\n  }\n  \n  // Adjust based on game progress\n  const gameProgressPercentage = (piecesCount / totalCells) * 100;\n  \n  if (gameProgressPercentage < 15) {\n    searchDepth += 2; // Deep search at beginning\n  } else if (gameProgressPercentage > 70) {\n    searchDepth += 3; // Very deep search near end\n  }\n  \n  // Evaluate potential moves with deeper minimax\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  // Prioritize center columns for initial evaluation\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  \n  for (const colIndex of orderedMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Check for immediate win\n    const winResult = checkWin(newBoard, rowIndex, colIndex);\n    if (winResult.win) {\n      return colIndex; // Immediate win found\n    }\n    \n    // Evaluate this move with deeper search\n    const score = minimax(newBoard, searchDepth, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  const COLS = board[0].length;\n  \n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 3; col < COLS; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column(s)\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n    // For even-width boards, also prefer the column to the left of center\n    if (COLS % 2 === 0 && centerCol > 0) {\n      if (board[row][centerCol - 1] === aiPlayer) {\n        score += 2;\n      }\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // Scoring based on pieces in window - enhanced for unbeatable AI\n  if (aiCount === 4) return 1000; // AI win - higher value\n  if (humanCount === 4) return -1000; // Human win - higher penalty\n  \n  if (aiCount === 3 && emptyCount === 1) return 50; // AI potential win - much higher priority\n  if (humanCount === 3 && emptyCount === 1) return -50; // Block human potential win - much higher priority\n  \n  if (aiCount === 2 && emptyCount === 2) return 10; // AI building up - higher value\n  if (humanCount === 2 && emptyCount === 2) return -10; // Human building up - higher penalty\n  \n  // New patterns\n  if (aiCount === 1 && emptyCount === 3) return 1; // Starting to build\n  if (humanCount === 1 && emptyCount === 3) return -1; // Human starting to build\n  \n  // Prefer empty windows slightly\n  if (emptyCount === 4) return 0.5;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  if (depth === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Prioritize center columns for evaluation\n  const COLS = board[0].length;\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  \n  if (isMaximizing) {\n    // AI's turn (maximizing)\n    let maxScore = -Infinity;\n    \n    for (const colIndex of orderedMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return 1000 * depth; // Winning sooner is better\n      }\n      \n      const score = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxScore = Math.max(maxScore, score);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, score);\n      if (beta <= alpha) break;\n    }\n    \n    return maxScore;\n  } else {\n    // Human's turn (minimizing)\n    let minScore = Infinity;\n    \n    for (const colIndex of orderedMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, colIndex, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return -1000 * depth; // Losing sooner is worse\n      }\n      \n      const score = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minScore = Math.min(minScore, score);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, score);\n      if (beta <= alpha) break;\n    }\n    \n    return minScore;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}