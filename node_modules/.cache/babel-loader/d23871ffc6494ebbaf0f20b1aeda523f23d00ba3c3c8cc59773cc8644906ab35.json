{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport{EMPTY,PLAYER_1,PLAYER_2,getValidMoves,makeMove,checkWin,isValidMove}from'./gameLogic';/**\n * AI personas with associated difficulty levels\n */export const AI_LEVEL={JIM:'easy',// Jim - Easy difficulty\nROSIE:'medium',// Rosie - Medium difficulty\nDANGERMOUSE:'hard'// Dangermouse - Hard difficulty\n};/**\n * AI persona descriptions\n */export const AI_PERSONA={[AI_LEVEL.JIM]:{name:'Jim',description:'Casual player who often makes random moves',avatar:'üë®‚Äçüíº'},[AI_LEVEL.ROSIE]:{name:'Rosie',description:'Strategic player who can spot obvious opportunities',avatar:'üë©‚Äçüî¨'},[AI_LEVEL.DANGERMOUSE]:{name:'Dangermouse',description:'Master tactician who plans several moves ahead',avatar:'üê≠'}};/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */export function getAIMove(board,aiPlayer){let difficulty=arguments.length>2&&arguments[2]!==undefined?arguments[2]:AI_LEVEL.MEDIUM;const humanPlayer=aiPlayer===PLAYER_1?PLAYER_2:PLAYER_1;switch(difficulty){case AI_LEVEL.JIM:return getRandomMove(board);case AI_LEVEL.ROSIE:return getMediumMove(board,aiPlayer,humanPlayer);case AI_LEVEL.DANGERMOUSE:return getHardMove(board,aiPlayer,humanPlayer);default:return getMediumMove(board,aiPlayer,humanPlayer);}}/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */function getRandomMove(board){const validMoves=getValidMoves(board);if(validMoves.length===0){return-1;// No valid moves\n}const randomIndex=Math.floor(Math.random()*validMoves.length);return validMoves[randomIndex];}/**\n * Medium difficulty AI: Uses minimax with moderate depth (same as old hard level)\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */function getMediumMove(board,aiPlayer,humanPlayer){// Check if AI can win in one move\nconst winningMove=findWinningMove(board,aiPlayer);if(winningMove!==-1){return winningMove;}// Block human player from winning in one move\nconst blockingMove=findWinningMove(board,humanPlayer);if(blockingMove!==-1){return blockingMove;}// Evaluate potential moves with minimax (limited depth)\nlet bestScore=-Infinity;let bestMove=-1;const validMoves=getValidMoves(board);for(const colIndex of validMoves){const{board:newBoard,rowIndex}=makeMove(board,colIndex,aiPlayer);// Skip invalid moves\nif(rowIndex===null)continue;// Evaluate this move (depth 4, same as old hard level)\nconst score=minimax(newBoard,4,false,aiPlayer,humanPlayer,-Infinity,Infinity);if(score>bestScore){bestScore=score;bestMove=colIndex;}}// If no good move found, use center or random\nif(bestMove===-1){const centerCol=Math.floor(board[0].length/2);bestMove=isValidMove(board,centerCol)?centerCol:getRandomMove(board);}return bestMove;}/**\n * Hard difficulty AI: Unbeatable AI using deep minimax search and advanced evaluation\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */function getHardMove(board,aiPlayer,humanPlayer){// Check if AI can win in one move\nconst winningMove=findWinningMove(board,aiPlayer);if(winningMove!==-1){return winningMove;}// Block human player from winning in one move\nconst blockingMove=findWinningMove(board,humanPlayer);if(blockingMove!==-1){return blockingMove;}// Count number of pieces to adjust search depth\nconst ROWS=board.length;const COLS=board[0].length;let piecesCount=0;let totalCells=ROWS*COLS;for(let row=0;row<ROWS;row++){for(let col=0;col<COLS;col++){if(board[row][col]!==EMPTY){piecesCount++;}}}// Adjust search depth based on game progress and board size\n// Deeper search at beginning and end, shallower in middle for performance\nlet searchDepth=6;// Default depth\n// For larger boards, reduce search depth to maintain performance\nif(totalCells>100){// Medium board (11x11 or larger)\nsearchDepth=5;}else if(totalCells>300){// Large board (21x21 or larger)\nsearchDepth=4;}// Adjust based on game progress\nconst gameProgressPercentage=piecesCount/totalCells*100;if(gameProgressPercentage<15){searchDepth+=2;// Deep search at beginning\n}else if(gameProgressPercentage>70){searchDepth+=3;// Very deep search near end\n}// Evaluate potential moves with deeper minimax\nlet bestScore=-Infinity;let bestMove=-1;const validMoves=getValidMoves(board);// Prioritize center columns for initial evaluation\nconst centerCol=Math.floor(COLS/2);const orderedMoves=[...validMoves].sort((a,b)=>{return Math.abs(centerCol-a)-Math.abs(centerCol-b);});for(const colIndex of orderedMoves){const{board:newBoard,rowIndex}=makeMove(board,colIndex,aiPlayer);// Skip invalid moves\nif(rowIndex===null)continue;// Check for immediate win\nconst winResult=checkWin(newBoard,rowIndex,colIndex);if(winResult.win){return colIndex;// Immediate win found\n}// Evaluate this move with deeper search\nconst score=minimax(newBoard,searchDepth,false,aiPlayer,humanPlayer,-Infinity,Infinity);if(score>bestScore){bestScore=score;bestMove=colIndex;}}// If no good move found, use center or random\nif(bestMove===-1){bestMove=isValidMove(board,centerCol)?centerCol:getRandomMove(board);}return bestMove;}/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */function findWinningMove(board,player){const COLS=board[0].length;for(let col=0;col<COLS;col++){if(!isValidMove(board,col))continue;const{board:newBoard,rowIndex}=makeMove(board,col,player);if(rowIndex!==null){const winResult=checkWin(newBoard,rowIndex,col);if(winResult.win){return col;}}}return-1;// No winning move found\n}/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */function evaluateBoard(board,aiPlayer,humanPlayer){let score=0;const ROWS=board.length;const COLS=board[0].length;// Evaluate horizontal windows\nfor(let row=0;row<ROWS;row++){for(let col=0;col<=COLS-4;col++){score+=evaluateWindow([board[row][col],board[row][col+1],board[row][col+2],board[row][col+3]],aiPlayer,humanPlayer);}}// Evaluate vertical windows\nfor(let col=0;col<COLS;col++){for(let row=0;row<=ROWS-4;row++){score+=evaluateWindow([board[row][col],board[row+1][col],board[row+2][col],board[row+3][col]],aiPlayer,humanPlayer);}}// Evaluate diagonal (down-right) windows\nfor(let row=0;row<=ROWS-4;row++){for(let col=0;col<=COLS-4;col++){score+=evaluateWindow([board[row][col],board[row+1][col+1],board[row+2][col+2],board[row+3][col+3]],aiPlayer,humanPlayer);}}// Evaluate diagonal (down-left) windows\nfor(let row=0;row<=ROWS-4;row++){for(let col=3;col<COLS;col++){score+=evaluateWindow([board[row][col],board[row+1][col-1],board[row+2][col-2],board[row+3][col-3]],aiPlayer,humanPlayer);}}// Prefer center column(s)\nconst centerCol=Math.floor(COLS/2);for(let row=0;row<ROWS;row++){if(board[row][centerCol]===aiPlayer){score+=3;}// For even-width boards, also prefer the column to the left of center\nif(COLS%2===0&&centerCol>0){if(board[row][centerCol-1]===aiPlayer){score+=2;}}}return score;}/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */function evaluateWindow(window,aiPlayer,humanPlayer){const aiCount=window.filter(cell=>cell===aiPlayer).length;const humanCount=window.filter(cell=>cell===humanPlayer).length;const emptyCount=window.filter(cell=>cell===EMPTY).length;// Scoring based on pieces in window - enhanced for unbeatable AI\nif(aiCount===4)return 1000;// AI win - higher value\nif(humanCount===4)return-1000;// Human win - higher penalty\nif(aiCount===3&&emptyCount===1)return 50;// AI potential win - much higher priority\nif(humanCount===3&&emptyCount===1)return-50;// Block human potential win - much higher priority\nif(aiCount===2&&emptyCount===2)return 10;// AI building up - higher value\nif(humanCount===2&&emptyCount===2)return-10;// Human building up - higher penalty\n// New patterns\nif(aiCount===1&&emptyCount===3)return 1;// Starting to build\nif(humanCount===1&&emptyCount===3)return-1;// Human starting to build\n// Prefer empty windows slightly\nif(emptyCount===4)return 0.5;return 0;}/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */function minimax(board,depth,isMaximizing,aiPlayer,humanPlayer,alpha,beta){// Terminal conditions\nif(depth===0){return evaluateBoard(board,aiPlayer,humanPlayer);}const validMoves=getValidMoves(board);if(validMoves.length===0){return evaluateBoard(board,aiPlayer,humanPlayer);}// Prioritize center columns for evaluation\nconst COLS=board[0].length;const centerCol=Math.floor(COLS/2);const orderedMoves=[...validMoves].sort((a,b)=>{return Math.abs(centerCol-a)-Math.abs(centerCol-b);});if(isMaximizing){// AI's turn (maximizing)\nlet maxScore=-Infinity;for(const colIndex of orderedMoves){const{board:newBoard,rowIndex}=makeMove(board,colIndex,aiPlayer);if(rowIndex===null)continue;// Check if this move wins\nconst winResult=checkWin(newBoard,rowIndex,colIndex);if(winResult.win){return 1000*depth;// Winning sooner is better\n}const score=minimax(newBoard,depth-1,false,aiPlayer,humanPlayer,alpha,beta);maxScore=Math.max(maxScore,score);// Alpha-beta pruning\nalpha=Math.max(alpha,score);if(beta<=alpha)break;}return maxScore;}else{// Human's turn (minimizing)\nlet minScore=Infinity;for(const colIndex of orderedMoves){const{board:newBoard,rowIndex}=makeMove(board,colIndex,humanPlayer);if(rowIndex===null)continue;// Check if this move wins\nconst winResult=checkWin(newBoard,rowIndex,colIndex);if(winResult.win){return-1000*depth;// Losing sooner is worse\n}const score=minimax(newBoard,depth-1,true,aiPlayer,humanPlayer,alpha,beta);minScore=Math.min(minScore,score);// Alpha-beta pruning\nbeta=Math.min(beta,score);if(beta<=alpha)break;}return minScore;}}","map":{"version":3,"names":["EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","JIM","ROSIE","DANGERMOUSE","AI_PERSONA","name","description","avatar","getAIMove","board","aiPlayer","difficulty","arguments","length","undefined","MEDIUM","humanPlayer","getRandomMove","getMediumMove","getHardMove","validMoves","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","centerCol","ROWS","COLS","piecesCount","totalCells","row","col","searchDepth","gameProgressPercentage","orderedMoves","sort","a","b","abs","winResult","win","player","evaluateBoard","evaluateWindow","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","maxScore","max","minScore","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',     // Jim - Easy difficulty\n  ROSIE: 'medium',  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard'  // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.JIM:\n      return getRandomMove(board);\n    case AI_LEVEL.ROSIE:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.DANGERMOUSE:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Uses minimax with moderate depth (same as old hard level)\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move (depth 4, same as old hard level)\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    const centerCol = Math.floor(board[0].length / 2);\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Hard difficulty AI: Unbeatable AI using deep minimax search and advanced evaluation\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Count number of pieces to adjust search depth\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  let piecesCount = 0;\n  let totalCells = ROWS * COLS;\n  \n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      if (board[row][col] !== EMPTY) {\n        piecesCount++;\n      }\n    }\n  }\n  \n  // Adjust search depth based on game progress and board size\n  // Deeper search at beginning and end, shallower in middle for performance\n  let searchDepth = 6; // Default depth\n  \n  // For larger boards, reduce search depth to maintain performance\n  if (totalCells > 100) { // Medium board (11x11 or larger)\n    searchDepth = 5;\n  } else if (totalCells > 300) { // Large board (21x21 or larger)\n    searchDepth = 4;\n  }\n  \n  // Adjust based on game progress\n  const gameProgressPercentage = (piecesCount / totalCells) * 100;\n  \n  if (gameProgressPercentage < 15) {\n    searchDepth += 2; // Deep search at beginning\n  } else if (gameProgressPercentage > 70) {\n    searchDepth += 3; // Very deep search near end\n  }\n  \n  // Evaluate potential moves with deeper minimax\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  // Prioritize center columns for initial evaluation\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  \n  for (const colIndex of orderedMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Check for immediate win\n    const winResult = checkWin(newBoard, rowIndex, colIndex);\n    if (winResult.win) {\n      return colIndex; // Immediate win found\n    }\n    \n    // Evaluate this move with deeper search\n    const score = minimax(newBoard, searchDepth, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, centerCol) ? centerCol : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  const COLS = board[0].length;\n  \n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 3; col < COLS; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column(s)\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n    // For even-width boards, also prefer the column to the left of center\n    if (COLS % 2 === 0 && centerCol > 0) {\n      if (board[row][centerCol - 1] === aiPlayer) {\n        score += 2;\n      }\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // Scoring based on pieces in window - enhanced for unbeatable AI\n  if (aiCount === 4) return 1000; // AI win - higher value\n  if (humanCount === 4) return -1000; // Human win - higher penalty\n  \n  if (aiCount === 3 && emptyCount === 1) return 50; // AI potential win - much higher priority\n  if (humanCount === 3 && emptyCount === 1) return -50; // Block human potential win - much higher priority\n  \n  if (aiCount === 2 && emptyCount === 2) return 10; // AI building up - higher value\n  if (humanCount === 2 && emptyCount === 2) return -10; // Human building up - higher penalty\n  \n  // New patterns\n  if (aiCount === 1 && emptyCount === 3) return 1; // Starting to build\n  if (humanCount === 1 && emptyCount === 3) return -1; // Human starting to build\n  \n  // Prefer empty windows slightly\n  if (emptyCount === 4) return 0.5;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  if (depth === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Prioritize center columns for evaluation\n  const COLS = board[0].length;\n  const centerCol = Math.floor(COLS / 2);\n  const orderedMoves = [...validMoves].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  \n  if (isMaximizing) {\n    // AI's turn (maximizing)\n    let maxScore = -Infinity;\n    \n    for (const colIndex of orderedMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return 1000 * depth; // Winning sooner is better\n      }\n      \n      const score = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxScore = Math.max(maxScore, score);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, score);\n      if (beta <= alpha) break;\n    }\n    \n    return maxScore;\n  } else {\n    // Human's turn (minimizing)\n    let minScore = Infinity;\n    \n    for (const colIndex of orderedMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, colIndex, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      // Check if this move wins\n      const winResult = checkWin(newBoard, rowIndex, colIndex);\n      if (winResult.win) {\n        return -1000 * depth; // Losing sooner is worse\n      }\n      \n      const score = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minScore = Math.min(minScore, score);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, score);\n      if (beta <= alpha) break;\n    }\n    \n    return minScore;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}