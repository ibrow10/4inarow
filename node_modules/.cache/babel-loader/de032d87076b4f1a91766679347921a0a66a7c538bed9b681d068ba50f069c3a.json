{"ast":null,"code":"// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n// Grid size options\nexport const GRID_SIZES = {\n  STANDARD: 'standard',\n  MEDIUM: 'medium',\n  LARGE: 'large'\n};\n\n// Grid dimensions for each size\nexport const GRID_DIMENSIONS = {\n  [GRID_SIZES.STANDARD]: {\n    rows: 6,\n    cols: 7\n  },\n  [GRID_SIZES.MEDIUM]: {\n    rows: 11,\n    cols: 11\n  },\n  [GRID_SIZES.LARGE]: {\n    rows: 21,\n    cols: 21\n  }\n};\n\n// Default grid size\nexport const DEFAULT_GRID_SIZE = GRID_SIZES.STANDARD;\n\n// Helper functions to get current dimensions\nexport function getRows(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].rows;\n}\nexport function getCols(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].cols;\n}\n\n/**\n * Create an empty game board\n * @param {string} gridSize - Size of the grid\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard(gridSize = DEFAULT_GRID_SIZE) {\n  const rows = getRows(gridSize);\n  const cols = getCols(gridSize);\n  return Array(rows).fill().map(() => Array(cols).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  const rows = board.length;\n  for (let row = rows - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n\n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return {\n      board: newBoard,\n      rowIndex: null\n    };\n  }\n\n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return {\n    board: newBoard,\n    rowIndex\n  };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = {\n    row: -direction.row,\n    col: -direction.col\n  };\n\n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {\n    winningCells.push({\n      row: r,\n      col: c\n    });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n\n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {\n    winningCells.push({\n      row: r,\n      col: c\n    });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [{\n    row: 0,\n    col: 1\n  },\n  // horizontal\n  {\n    row: 1,\n    col: 0\n  },\n  // vertical\n  {\n    row: 1,\n    col: 1\n  },\n  // diagonal down-right\n  {\n    row: 1,\n    col: -1\n  } // diagonal down-left\n  ];\n  const player = board[rowIndex][colIndex];\n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  return {\n    win: false,\n    winningCells: []\n  };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return {\n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  const cols = board[0].length;\n\n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= cols) {\n    return false;\n  }\n\n  // Check if the top cell in the column is empty\n  return board[0][colIndex] === EMPTY;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  const validMoves = [];\n  const cols = board[0].length;\n  for (let col = 0; col < cols; col++) {\n    if (isValidMove(board, col)) {\n      validMoves.push(col);\n    }\n  }\n  return validMoves;\n}","map":{"version":3,"names":["EMPTY","PLAYER_1","PLAYER_2","GRID_SIZES","STANDARD","MEDIUM","LARGE","GRID_DIMENSIONS","rows","cols","DEFAULT_GRID_SIZE","getRows","gridSize","getCols","createEmptyBoard","Array","fill","map","findLowestEmptyRow","board","colIndex","length","row","isBoardFull","every","cell","makeMove","player","newBoard","rowIndex","checkDirection","col","direction","winningCells","oppositeDirection","count","r","c","ROWS","COLS","push","win","checkWin","directions","result","getGameStatus","lastRow","lastCol","status","winner","winResult","isValidMove","getValidMoves","validMoves"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/gameLogic.js"],"sourcesContent":["// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n// Grid size options\nexport const GRID_SIZES = {\n  STANDARD: 'standard',\n  MEDIUM: 'medium',\n  LARGE: 'large'\n};\n\n// Grid dimensions for each size\nexport const GRID_DIMENSIONS = {\n  [GRID_SIZES.STANDARD]: { rows: 6, cols: 7 },\n  [GRID_SIZES.MEDIUM]: { rows: 11, cols: 11 },\n  [GRID_SIZES.LARGE]: { rows: 21, cols: 21 }\n};\n\n// Default grid size\nexport const DEFAULT_GRID_SIZE = GRID_SIZES.STANDARD;\n\n// Helper functions to get current dimensions\nexport function getRows(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].rows;\n}\n\nexport function getCols(gridSize = DEFAULT_GRID_SIZE) {\n  return GRID_DIMENSIONS[gridSize].cols;\n}\n\n/**\n * Create an empty game board\n * @param {string} gridSize - Size of the grid\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard(gridSize = DEFAULT_GRID_SIZE) {\n  const rows = getRows(gridSize);\n  const cols = getCols(gridSize);\n  return Array(rows).fill().map(() => Array(cols).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  const rows = board.length;\n  for (let row = rows - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n  \n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return { board: newBoard, rowIndex: null };\n  }\n  \n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return { board: newBoard, rowIndex };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = { row: -direction.row, col: -direction.col };\n  \n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n  \n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  \n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [\n    { row: 0, col: 1 },  // horizontal\n    { row: 1, col: 0 },  // vertical\n    { row: 1, col: 1 },  // diagonal down-right\n    { row: 1, col: -1 }, // diagonal down-left\n  ];\n  \n  const player = board[rowIndex][colIndex];\n  \n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  \n  return { win: false, winningCells: [] };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return { \n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  \n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  const cols = board[0].length;\n  \n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= cols) {\n    return false;\n  }\n  \n  // Check if the top cell in the column is empty\n  return board[0][colIndex] === EMPTY;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  const validMoves = [];\n  const cols = board[0].length;\n  \n  for (let col = 0; col < cols; col++) {\n    if (isValidMove(board, col)) {\n      validMoves.push(col);\n    }\n  }\n  \n  return validMoves;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}