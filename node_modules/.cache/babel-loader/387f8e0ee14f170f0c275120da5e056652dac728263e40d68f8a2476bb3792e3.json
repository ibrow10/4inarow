{"ast":null,"code":"// gameLogic.js - Core Connect 4 logic\n// Constants\nexport const ROWS=6;export const COLS=7;export const EMPTY=null;export const PLAYER_1=1;export const PLAYER_2=2;/**\n * Create an empty game board\n * @returns {Array<Array<null>>} Empty board\n */export function createEmptyBoard(){return Array(ROWS).fill().map(()=>Array(COLS).fill(EMPTY));}/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */export function findLowestEmptyRow(board,colIndex){for(let row=ROWS-1;row>=0;row--){if(board[row][colIndex]===EMPTY){return row;}}return-1;// Column is full\n}/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */export function isBoardFull(board){return board[0].every(cell=>cell!==EMPTY);}/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */export function makeMove(board,colIndex,player){// Create a copy of the board\nconst newBoard=board.map(row=>[...row]);const rowIndex=findLowestEmptyRow(board,colIndex);// Invalid move (column is full)\nif(rowIndex===-1){return{board:newBoard,rowIndex:null};}// Make the move\nnewBoard[rowIndex][colIndex]=player;return{board:newBoard,rowIndex};}/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */export function checkDirection(board,row,col,direction,player){const winningCells=[];const oppositeDirection={row:-direction.row,col:-direction.col};// Check in the positive direction\nlet count=0;let r=row;let c=col;while(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===player){winningCells.push({row:r,col:c});count++;r+=direction.row;c+=direction.col;}// Check in the negative direction\nr=row+oppositeDirection.row;c=col+oppositeDirection.col;while(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===player){winningCells.push({row:r,col:c});count++;r+=oppositeDirection.row;c+=oppositeDirection.col;}return{win:count>=4,winningCells:count>=4?winningCells:[]};}/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */export function checkWin(board,rowIndex,colIndex){const directions=[{row:0,col:1},// horizontal\n{row:1,col:0},// vertical\n{row:1,col:1},// diagonal down-right\n{row:1,col:-1}// diagonal down-left\n];const player=board[rowIndex][colIndex];for(const direction of directions){const result=checkDirection(board,rowIndex,colIndex,direction,player);if(result.win)return result;}return{win:false,winningCells:[]};}/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */export function getGameStatus(board,lastRow,lastCol){if(lastRow===null||lastCol===null){return{status:'inProgress',winner:null,winningCells:[]};}const winResult=checkWin(board,lastRow,lastCol);if(winResult.win){return{status:'win',winner:board[lastRow][lastCol],winningCells:winResult.winningCells};}if(isBoardFull(board)){return{status:'draw',winner:null,winningCells:[]};}return{status:'inProgress',winner:null,winningCells:[]};}/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */export function isValidMove(board,colIndex){// Check if column is within bounds\nif(colIndex<0||colIndex>=COLS){return false;}// Check if column is not full\nreturn findLowestEmptyRow(board,colIndex)!==-1;}/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */export function getValidMoves(board){return Array(COLS).fill().map((_,i)=>i).filter(colIndex=>isValidMove(board,colIndex));}","map":{"version":3,"names":["ROWS","COLS","EMPTY","PLAYER_1","PLAYER_2","createEmptyBoard","Array","fill","map","findLowestEmptyRow","board","colIndex","row","isBoardFull","every","cell","makeMove","player","newBoard","rowIndex","checkDirection","col","direction","winningCells","oppositeDirection","count","r","c","push","win","checkWin","directions","result","getGameStatus","lastRow","lastCol","status","winner","winResult","isValidMove","getValidMoves","_","i","filter"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/gameLogic.js"],"sourcesContent":["// gameLogic.js - Core Connect 4 logic\n\n// Constants\nexport const ROWS = 6;\nexport const COLS = 7;\nexport const EMPTY = null;\nexport const PLAYER_1 = 1;\nexport const PLAYER_2 = 2;\n\n/**\n * Create an empty game board\n * @returns {Array<Array<null>>} Empty board\n */\nexport function createEmptyBoard() {\n  return Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));\n}\n\n/**\n * Find the lowest empty row in a column\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column index\n * @returns {number} Row index or -1 if column is full\n */\nexport function findLowestEmptyRow(board, colIndex) {\n  for (let row = ROWS - 1; row >= 0; row--) {\n    if (board[row][colIndex] === EMPTY) {\n      return row;\n    }\n  }\n  return -1; // Column is full\n}\n\n/**\n * Check if the board is full (draw condition)\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {boolean} True if board is full\n */\nexport function isBoardFull(board) {\n  return board[0].every(cell => cell !== EMPTY);\n}\n\n/**\n * Make a move on the board\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to make move\n * @param {number} player - Player making the move\n * @returns {Object} New board and row where piece was placed, or null if invalid\n */\nexport function makeMove(board, colIndex, player) {\n  // Create a copy of the board\n  const newBoard = board.map(row => [...row]);\n  const rowIndex = findLowestEmptyRow(board, colIndex);\n  \n  // Invalid move (column is full)\n  if (rowIndex === -1) {\n    return { board: newBoard, rowIndex: null };\n  }\n  \n  // Make the move\n  newBoard[rowIndex][colIndex] = player;\n  return { board: newBoard, rowIndex };\n}\n\n/**\n * Check for a win in a specific direction\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} row - Row of last move\n * @param {number} col - Column of last move\n * @param {Object} direction - Direction to check\n * @param {number} player - Player to check for win\n * @returns {Object} Result including win status and winning cells\n */\nexport function checkDirection(board, row, col, direction, player) {\n  const winningCells = [];\n  const oppositeDirection = { row: -direction.row, col: -direction.col };\n  \n  // Check in the positive direction\n  let count = 0;\n  let r = row;\n  let c = col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += direction.row;\n    c += direction.col;\n  }\n  \n  // Check in the negative direction\n  r = row + oppositeDirection.row;\n  c = col + oppositeDirection.col;\n  \n  while (\n    r >= 0 && r < ROWS &&\n    c >= 0 && c < COLS &&\n    board[r][c] === player\n  ) {\n    winningCells.push({ row: r, col: c });\n    count++;\n    r += oppositeDirection.row;\n    c += oppositeDirection.col;\n  }\n  \n  return {\n    win: count >= 4,\n    winningCells: count >= 4 ? winningCells : []\n  };\n}\n\n/**\n * Check if the last move resulted in a win\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} rowIndex - Row of last move\n * @param {number} colIndex - Column of last move\n * @returns {Object} Win result with status and winning cells\n */\nexport function checkWin(board, rowIndex, colIndex) {\n  const directions = [\n    { row: 0, col: 1 },  // horizontal\n    { row: 1, col: 0 },  // vertical\n    { row: 1, col: 1 },  // diagonal down-right\n    { row: 1, col: -1 }, // diagonal down-left\n  ];\n  \n  const player = board[rowIndex][colIndex];\n  \n  for (const direction of directions) {\n    const result = checkDirection(board, rowIndex, colIndex, direction, player);\n    if (result.win) return result;\n  }\n  \n  return { win: false, winningCells: [] };\n}\n\n/**\n * Get the current game status\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} lastRow - Row of last move\n * @param {number} lastCol - Column of last move\n * @returns {Object} Game status (inProgress, win, or draw) and details\n */\nexport function getGameStatus(board, lastRow, lastCol) {\n  if (lastRow === null || lastCol === null) {\n    return { \n      status: 'inProgress',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  const winResult = checkWin(board, lastRow, lastCol);\n  if (winResult.win) {\n    return {\n      status: 'win',\n      winner: board[lastRow][lastCol],\n      winningCells: winResult.winningCells\n    };\n  }\n  \n  if (isBoardFull(board)) {\n    return {\n      status: 'draw',\n      winner: null,\n      winningCells: []\n    };\n  }\n  \n  return {\n    status: 'inProgress',\n    winner: null,\n    winningCells: []\n  };\n}\n\n/**\n * Check if a move is valid\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} colIndex - Column to check\n * @returns {boolean} True if move is valid\n */\nexport function isValidMove(board, colIndex) {\n  // Check if column is within bounds\n  if (colIndex < 0 || colIndex >= COLS) {\n    return false;\n  }\n  \n  // Check if column is not full\n  return findLowestEmptyRow(board, colIndex) !== -1;\n}\n\n/**\n * Get all valid moves\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {Array<number>} Array of valid column indices\n */\nexport function getValidMoves(board) {\n  return Array(COLS).fill()\n    .map((_, i) => i)\n    .filter(colIndex => isValidMove(board, colIndex));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}