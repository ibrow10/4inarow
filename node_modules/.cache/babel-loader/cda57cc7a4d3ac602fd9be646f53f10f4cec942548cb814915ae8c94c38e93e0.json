{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport { EMPTY, PLAYER_1, PLAYER_2, getValidMoves, makeMove, checkWin, isValidMove } from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',\n  // Jim - Easy difficulty\n  ROSIE: 'medium',\n  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard' // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n\n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  for (const colIndex of validMoves) {\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, colIndex, aiPlayer);\n\n    // Skip invalid moves\n    if (rowIndex === null) continue;\n\n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n\n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  const ROWS = board.length;\n  const COLS = board[0].length;\n\n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row][col + 1], board[row][col + 2], board[row][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col], board[row + 2][col], board[row + 3][col]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col + 1], board[row + 2][col + 2], board[row + 3][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 3; col < COLS; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col - 1], board[row + 2][col - 2], board[row + 3][col - 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Prefer center column(s)\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n    // For even-width boards, also prefer the column to the left of center\n    if (COLS % 2 === 0 && centerCol > 0) {\n      if (board[row][centerCol - 1] === aiPlayer) {\n        score += 2;\n      }\n    }\n  }\n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n\n  // AI win\n  if (aiCount === 4) return 100;\n\n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n\n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n\n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n\n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n\n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Prioritize center columns for initial evaluation\n  const centerCol = Math.floor(board[0].length / 2);\n  const orderedMoves = [...getValidMoves(board)].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n\n  // Terminal conditions\n  if (depth === 0 || orderedMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n\n  // Check for immediate wins/losses\n  for (const col of orderedMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, aiPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n\n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, humanPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n\n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    return minEval;\n  }\n}","map":{"version":3,"names":["EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","JIM","ROSIE","DANGERMOUSE","AI_PERSONA","name","description","avatar","getAIMove","board","aiPlayer","difficulty","MEDIUM","humanPlayer","EASY","getRandomMove","getMediumMove","HARD","getHardMove","validMoves","length","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","centerColumn","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","player","col","COLS","winResult","win","evaluateBoard","ROWS","row","evaluateWindow","centerCol","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","orderedMoves","sort","a","b","abs","maxEval","evalScore","max","minEval","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',     // Jim - Easy difficulty\n  ROSIE: 'medium',  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard'  // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n  \n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  const ROWS = board.length;\n  const COLS = board[0].length;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 3; col < COLS; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column(s)\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n    // For even-width boards, also prefer the column to the left of center\n    if (COLS % 2 === 0 && centerCol > 0) {\n      if (board[row][centerCol - 1] === aiPlayer) {\n        score += 2;\n      }\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // AI win\n  if (aiCount === 4) return 100;\n  \n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n  \n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n  \n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n  \n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n  \n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Prioritize center columns for initial evaluation\n  const centerCol = Math.floor(board[0].length / 2);\n  const orderedMoves = [...getValidMoves(board)].sort((a, b) => {\n    return Math.abs(centerCol - a) - Math.abs(centerCol - b);\n  });\n  \n  // Terminal conditions\n  if (depth === 0 || orderedMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Check for immediate wins/losses\n  for (const col of orderedMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  \n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return minEval;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}