{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport { COLS, ROWS, EMPTY, PLAYER_1, PLAYER_2, getValidMoves, makeMove, checkWin, isValidMove } from './gameLogic';\n\n/**\n * AI difficulty levels\n */\nexport const AI_LEVEL = {\n  EASY: 'easy',\n  MEDIUM: 'medium',\n  HARD: 'hard'\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n\n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  for (const colIndex of validMoves) {\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, colIndex, aiPlayer);\n\n    // Skip invalid moves\n    if (rowIndex === null) continue;\n\n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n\n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n\n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row][col + 1], board[row][col + 2], board[row][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col], board[row + 2][col], board[row + 3][col]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col + 1], board[row + 2][col + 2], board[row + 3][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = COLS - 1; col >= 3; col--) {\n      score += evaluateWindow([board[row][col], board[row + 1][col - 1], board[row + 2][col - 2], board[row + 3][col - 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Prefer center column\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n  }\n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n\n  // AI win\n  if (aiCount === 4) return 100;\n\n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n\n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n\n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n\n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n\n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  const validMoves = getValidMoves(board);\n\n  // Game over or max depth reached\n  if (depth === 0 || validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n\n  // Check for immediate wins/losses\n  for (const col of validMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, aiPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n\n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, humanPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n\n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    return minEval;\n  }\n}","map":{"version":3,"names":["COLS","ROWS","EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","EASY","MEDIUM","HARD","getAIMove","board","aiPlayer","difficulty","humanPlayer","getRandomMove","getMediumMove","getHardMove","validMoves","length","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","centerColumn","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","player","col","winResult","win","evaluateBoard","row","evaluateWindow","centerCol","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","maxEval","evalScore","max","minEval","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  COLS,\n  ROWS,\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI difficulty levels\n */\nexport const AI_LEVEL = {\n  EASY: 'easy',\n  MEDIUM: 'medium',\n  HARD: 'hard'\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n  \n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = COLS - 1; col >= 3; col--) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // AI win\n  if (aiCount === 4) return 100;\n  \n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n  \n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n  \n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n  \n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n  \n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  const validMoves = getValidMoves(board);\n  \n  // Game over or max depth reached\n  if (depth === 0 || validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Check for immediate wins/losses\n  for (const col of validMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  \n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return minEval;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}