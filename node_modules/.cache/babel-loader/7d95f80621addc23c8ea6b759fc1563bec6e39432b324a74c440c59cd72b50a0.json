{"ast":null,"code":"// aiPlayer.js - AI logic for Connect 4 game\nimport { COLS, ROWS, EMPTY, PLAYER_1, PLAYER_2, getValidMoves, makeMove, checkWin, isValidMove } from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',\n  // Jim - Easy difficulty\n  ROSIE: 'medium',\n  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard' // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n\n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n\n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n\n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  for (const colIndex of validMoves) {\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, colIndex, aiPlayer);\n\n    // Skip invalid moves\n    if (rowIndex === null) continue;\n\n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n\n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n\n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row][col + 1], board[row][col + 2], board[row][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col], board[row + 2][col], board[row + 3][col]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow([board[row][col], board[row + 1][col + 1], board[row + 2][col + 2], board[row + 3][col + 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = COLS - 1; col >= 3; col--) {\n      score += evaluateWindow([board[row][col], board[row + 1][col - 1], board[row + 2][col - 2], board[row + 3][col - 3]], aiPlayer, humanPlayer);\n    }\n  }\n\n  // Prefer center column\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n  }\n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n\n  // AI win\n  if (aiCount === 4) return 100;\n\n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n\n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n\n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n\n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n\n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  const validMoves = getValidMoves(board);\n\n  // Game over or max depth reached\n  if (depth === 0 || validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n\n  // Check for immediate wins/losses\n  for (const col of validMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const {\n      board: newBoard,\n      rowIndex\n    } = makeMove(board, col, player);\n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, aiPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n\n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    for (const col of validMoves) {\n      const {\n        board: newBoard,\n        rowIndex\n      } = makeMove(board, col, humanPlayer);\n      if (rowIndex === null) continue;\n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n\n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    return minEval;\n  }\n}","map":{"version":3,"names":["COLS","ROWS","EMPTY","PLAYER_1","PLAYER_2","getValidMoves","makeMove","checkWin","isValidMove","AI_LEVEL","JIM","ROSIE","DANGERMOUSE","AI_PERSONA","name","description","avatar","getAIMove","board","aiPlayer","difficulty","MEDIUM","humanPlayer","EASY","getRandomMove","getMediumMove","HARD","getHardMove","validMoves","length","randomIndex","Math","floor","random","winningMove","findWinningMove","blockingMove","centerColumn","bestScore","Infinity","bestMove","colIndex","newBoard","rowIndex","score","minimax","player","col","winResult","win","evaluateBoard","row","evaluateWindow","centerCol","window","aiCount","filter","cell","humanCount","emptyCount","depth","isMaximizing","alpha","beta","maxEval","evalScore","max","minEval","min"],"sources":["/Users/ianjbrowne/Library/Mobile Documents/com~apple~CloudDocs/ibrow10/Connect4/src/aiPlayer.js"],"sourcesContent":["// aiPlayer.js - AI logic for Connect 4 game\nimport {\n  COLS,\n  ROWS,\n  EMPTY,\n  PLAYER_1,\n  PLAYER_2,\n  getValidMoves,\n  makeMove,\n  checkWin,\n  isValidMove\n} from './gameLogic';\n\n/**\n * AI personas with associated difficulty levels\n */\nexport const AI_LEVEL = {\n  JIM: 'easy',     // Jim - Easy difficulty\n  ROSIE: 'medium',  // Rosie - Medium difficulty\n  DANGERMOUSE: 'hard'  // Dangermouse - Hard difficulty\n};\n\n/**\n * AI persona descriptions\n */\nexport const AI_PERSONA = {\n  [AI_LEVEL.JIM]: {\n    name: 'Jim',\n    description: 'Casual player who often makes random moves',\n    avatar: 'üë®‚Äçüíº'\n  },\n  [AI_LEVEL.ROSIE]: {\n    name: 'Rosie',\n    description: 'Strategic player who can spot obvious opportunities',\n    avatar: 'üë©‚Äçüî¨'\n  },\n  [AI_LEVEL.DANGERMOUSE]: {\n    name: 'Dangermouse',\n    description: 'Master tactician who plans several moves ahead',\n    avatar: 'üê≠'\n  }\n};\n\n/**\n * Get AI move based on difficulty level\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number (PLAYER_1 or PLAYER_2)\n * @param {string} difficulty - AI difficulty level\n * @returns {number} Column index for AI move\n */\nexport function getAIMove(board, aiPlayer, difficulty = AI_LEVEL.MEDIUM) {\n  const humanPlayer = aiPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  \n  switch (difficulty) {\n    case AI_LEVEL.EASY:\n      return getRandomMove(board);\n    case AI_LEVEL.MEDIUM:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n    case AI_LEVEL.HARD:\n      return getHardMove(board, aiPlayer, humanPlayer);\n    default:\n      return getMediumMove(board, aiPlayer, humanPlayer);\n  }\n}\n\n/**\n * Get a random valid move\n * @param {Array<Array<null|number>>} board - Current game board\n * @returns {number} Column index for move\n */\nfunction getRandomMove(board) {\n  const validMoves = getValidMoves(board);\n  \n  if (validMoves.length === 0) {\n    return -1; // No valid moves\n  }\n  \n  const randomIndex = Math.floor(Math.random() * validMoves.length);\n  return validMoves[randomIndex];\n}\n\n/**\n * Medium difficulty AI: Blocks obvious wins and takes obvious wins\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getMediumMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Prefer center column\n  const centerColumn = 3;\n  if (isValidMove(board, centerColumn)) {\n    return centerColumn;\n  }\n  \n  // Otherwise make a random move\n  return getRandomMove(board);\n}\n\n/**\n * Hard difficulty AI: Uses deeper evaluation and looks ahead\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Column index for move\n */\nfunction getHardMove(board, aiPlayer, humanPlayer) {\n  // Check if AI can win in one move\n  const winningMove = findWinningMove(board, aiPlayer);\n  if (winningMove !== -1) {\n    return winningMove;\n  }\n  \n  // Block human player from winning in one move\n  const blockingMove = findWinningMove(board, humanPlayer);\n  if (blockingMove !== -1) {\n    return blockingMove;\n  }\n  \n  // Evaluate potential moves with minimax (limited depth)\n  let bestScore = -Infinity;\n  let bestMove = -1;\n  const validMoves = getValidMoves(board);\n  \n  for (const colIndex of validMoves) {\n    const { board: newBoard, rowIndex } = makeMove(board, colIndex, aiPlayer);\n    \n    // Skip invalid moves\n    if (rowIndex === null) continue;\n    \n    // Evaluate this move\n    const score = minimax(newBoard, 4, false, aiPlayer, humanPlayer, -Infinity, Infinity);\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = colIndex;\n    }\n  }\n  \n  // If no good move found, use center or random\n  if (bestMove === -1) {\n    bestMove = isValidMove(board, 3) ? 3 : getRandomMove(board);\n  }\n  \n  return bestMove;\n}\n\n/**\n * Find a winning move for the given player\n * @param {Array<Array<null|number>>} board - Current game board\n * @param {number} player - Player to find winning move for\n * @returns {number} Column index for winning move or -1 if none found\n */\nfunction findWinningMove(board, player) {\n  for (let col = 0; col < COLS; col++) {\n    if (!isValidMove(board, col)) continue;\n    \n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return col;\n      }\n    }\n  }\n  \n  return -1; // No winning move found\n}\n\n/**\n * Evaluate the board position for the AI player\n * Positive score is good for AI, negative is good for human\n * @param {Array<Array<null|number>>} board - Game board\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for the position\n */\nfunction evaluateBoard(board, aiPlayer, humanPlayer) {\n  let score = 0;\n  \n  // Evaluate horizontal windows\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate vertical windows\n  for (let col = 0; col < COLS; col++) {\n    for (let row = 0; row <= ROWS - 4; row++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-right) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = 0; col <= COLS - 4; col++) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Evaluate diagonal (down-left) windows\n  for (let row = 0; row <= ROWS - 4; row++) {\n    for (let col = COLS - 1; col >= 3; col--) {\n      score += evaluateWindow(\n        [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]],\n        aiPlayer,\n        humanPlayer\n      );\n    }\n  }\n  \n  // Prefer center column\n  const centerCol = Math.floor(COLS / 2);\n  for (let row = 0; row < ROWS; row++) {\n    if (board[row][centerCol] === aiPlayer) {\n      score += 3;\n    }\n  }\n  \n  return score;\n}\n\n/**\n * Evaluate a window of 4 cells\n * @param {Array<null|number>} window - Array of 4 cells\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @returns {number} Score for this window\n */\nfunction evaluateWindow(window, aiPlayer, humanPlayer) {\n  const aiCount = window.filter(cell => cell === aiPlayer).length;\n  const humanCount = window.filter(cell => cell === humanPlayer).length;\n  const emptyCount = window.filter(cell => cell === EMPTY).length;\n  \n  // AI win\n  if (aiCount === 4) return 100;\n  \n  // AI can win next move\n  if (aiCount === 3 && emptyCount === 1) return 5;\n  \n  // AI has two in a row with spaces\n  if (aiCount === 2 && emptyCount === 2) return 2;\n  \n  // Human win (very bad)\n  if (humanCount === 4) return -100;\n  \n  // Human can win next move (block urgently)\n  if (humanCount === 3 && emptyCount === 1) return -10;\n  \n  // Human has two in a row with spaces\n  if (humanCount === 2 && emptyCount === 2) return -2;\n  \n  return 0;\n}\n\n/**\n * Minimax algorithm for evaluating future positions (with alpha-beta pruning)\n * @param {Array<Array<null|number>>} board - Current board\n * @param {number} depth - Search depth remaining\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} aiPlayer - AI player number\n * @param {number} humanPlayer - Human player number\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} Score for this position\n */\nfunction minimax(board, depth, isMaximizing, aiPlayer, humanPlayer, alpha, beta) {\n  // Terminal conditions\n  const validMoves = getValidMoves(board);\n  \n  // Game over or max depth reached\n  if (depth === 0 || validMoves.length === 0) {\n    return evaluateBoard(board, aiPlayer, humanPlayer);\n  }\n  \n  // Check for immediate wins/losses\n  for (const col of validMoves) {\n    const player = isMaximizing ? aiPlayer : humanPlayer;\n    const { board: newBoard, rowIndex } = makeMove(board, col, player);\n    \n    if (rowIndex !== null) {\n      const winResult = checkWin(newBoard, rowIndex, col);\n      if (winResult.win) {\n        return isMaximizing ? 1000 : -1000;\n      }\n    }\n  }\n  \n  if (isMaximizing) {\n    let maxEval = -Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, aiPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, false, aiPlayer, humanPlayer, alpha, beta);\n      maxEval = Math.max(maxEval, evalScore);\n      \n      // Alpha-beta pruning\n      alpha = Math.max(alpha, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const col of validMoves) {\n      const { board: newBoard, rowIndex } = makeMove(board, col, humanPlayer);\n      \n      if (rowIndex === null) continue;\n      \n      const evalScore = minimax(newBoard, depth - 1, true, aiPlayer, humanPlayer, alpha, beta);\n      minEval = Math.min(minEval, evalScore);\n      \n      // Alpha-beta pruning\n      beta = Math.min(beta, evalScore);\n      if (beta <= alpha) break;\n    }\n    \n    return minEval;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}